/**
 * multisocket.{cc,hh} -- multiple connection between two ports
 * @author Sudi Lyu <sudil@andrew.cmu.edu>
 *
 * Usage: MultiSocket(LOCAL_IP, LOCAL_PORT, REMOTE_IP, REMOTE_PORT)
 *
 * The multisocket element will listen on LOCAL_IP:LOCAL_PORT and accept every
 * tcp connection. For each connection, multisocket will open a corresponding
 * connection to REMOTE_IP:REMOTE_PORT, so it knows the destination of every packet
 * that come from any connection. So, for each packet come from connection,
 * multisocket will insert its destination file descriptor before packet and
 * then push it to click output. For each packet come from click input,
 * multisocket know the position of destination file descriptor,
 * so it read from destination, delete it from packet and then send it to
 * destination file descriptor.
 *
 * Note that because of this packet modification, the packet that push to
 * click output could only be used by same multisocket object itself and the
 * packet pushed to multisocket click input must be generated by same
 * multisocket object.
 */

#include <click/config.h>
#include <click/error.hh>
#include <click/args.hh>
#include <click/glue.hh>
#include <click/packet_anno.hh>
#include <click/packet.hh>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>
#include <fcntl.h>
#include "multisocket.hh"

#ifdef HAVE_PROPER
#include <proper/prop.h>
#endif

CLICK_DECLS

MultiSocket::MultiSocket()
        : _listen_fd(-1), _remote_port(0), _local_port(0), _timestamp(true),
          _snaplen(2048), _headroom(Packet::default_headroom),
          _verbose(false)
{
}

MultiSocket::~MultiSocket()
{
}

int
MultiSocket::configure(Vector<String> &conf, ErrorHandler *errh)
{
    Args args = Args(this, errh).bind(conf);

    _protocol = IPPROTO_TCP;
    if (args.read_mp("ADDR", _local_ip)
                .read_mp("PORT", IPPortArg(_protocol), _local_port)
                .read_mp("ADDR", _remote_ip)
                .read_mp("PORT", IPPortArg(_protocol), _remote_port)
                .complete() < 0)
        return -1;

    return 0;
}

int
MultiSocket::initialize_socket_error(ErrorHandler *errh, const char *syscall)
{
    int e = errno;		// preserve errno

    if (_listen_fd >= 0) {
        remove_select(_listen_fd, SELECT_READ | SELECT_WRITE);
        close(_listen_fd);
        _listen_fd = -1;
    }

    return errh->error("%s: %s", syscall, strerror(e));
}

int
MultiSocket::initialize(ErrorHandler *errh)
{
    for (int i = 0;i < MAX_CONNECTION_NUM;i++) {
        _client_fd[i] = -1;
        _server_fd[i] = -1;
        _connection_index[i] = -1;
        _connection_index[MAX_CONNECTION_NUM + i] = -1;
    }

    // open socket, set options
    _listen_fd = socket(AF_INET, SOCK_STREAM, _protocol);
    if (_listen_fd < 0)
        return initialize_socket_error(errh, "socket");

    _remote.sin_family = AF_INET;
    _remote.sin_port = htons(_remote_port);
    _remote.sin_addr = _remote_ip.in_addr();
    _remote_len = sizeof(_remote);

    _local.sin_family = AF_INET;
    _local.sin_port = htons(_local_port);
    _local.sin_addr = _local_ip.in_addr();
    _local_len = sizeof(_local);

    if (bind(_listen_fd, (struct sockaddr *)&_local, _local_len) < 0)
        return initialize_socket_error(errh, "bind");

    // start listening
    if (listen(_listen_fd, 2) < 0)
        return initialize_socket_error(errh, "listen");
    if (_verbose) {
        click_chatter("%s: listening for connections on %s:%d (%d)",
                declaration().c_str(),
                IPAddress(_local.sin_addr).unparse().c_str(),
                ntohs(_local.sin_port), _listen_fd);
    }

    // nonblocking I/O and close-on-exec for the socket
    fcntl(_listen_fd, F_SETFL, O_NONBLOCK);
    fcntl(_listen_fd, F_SETFD, FD_CLOEXEC);

    add_select(_listen_fd, SELECT_READ);
    return 0;
}

void
MultiSocket::cleanup(CleanupStage)
{
    for (int i = 0;i < MAX_CONNECTION_NUM;i++) {
        if (_client_fd[i] > 0) {
            close(_client_fd[i]);
            _connection_index[_client_fd[i]] = -1;
            _client_fd[i] = -1;
        }

        if (_server_fd[i] > 0) {
            close(_server_fd[i]);
            _connection_index[_server_fd[i]] = -1;
            _server_fd[i] = -1;
        }
    }

    if (_listen_fd >= 0) {
        // shut down the listening socket in case we forked
#ifdef SHUT_RDWR
        shutdown(_listen_fd, SHUT_RDWR);
#else
        shutdown(_listen_fd, 2);
#endif
        close(_listen_fd);
        _listen_fd = -1;
    }
}

void
MultiSocket::close_fd(int fd)
{
    int connection = _connection_index[fd];
    remove_select(_client_fd[connection], SELECT_READ | SELECT_WRITE);
    remove_select(_server_fd[connection], SELECT_READ | SELECT_WRITE);
    close(_client_fd[connection]);
    close(_server_fd[connection]);
    if (_verbose) {
        click_chatter("%s: closed client connection %d", declaration().c_str(), _client_fd[connection]);
        click_chatter("%s: closed server connection %d", declaration().c_str(), _server_fd[connection]);
    }
    _connection_index[_client_fd[connection]] = -1;
    _connection_index[_server_fd[connection]] = -1;
    _client_fd[connection] = -1;
    _server_fd[connection] = -1;
}

void
MultiSocket::selected(int fd, int) {
    int len;
    struct sockaddr_in from;
    socklen_t from_len = sizeof(from);

    // accept new connections
    if (fd == _listen_fd) {
        int _c = accept(_listen_fd, (struct sockaddr *) &from, &from_len);

        if (_c < 0) {
            if (errno != EAGAIN)
                click_chatter("%s: accept: %s", declaration().c_str(), strerror(errno));
            return;
        }

        if (_verbose)
            click_chatter("%s: %s connection %d from %s:%d", declaration().c_str(),
                          "opened", _c, IPAddress(from.sin_addr).unparse().c_str(), ntohs(from.sin_port));

        fcntl(_c, F_SETFL, O_NONBLOCK);
        fcntl(_c, F_SETFD, FD_CLOEXEC);

        add_select(_c, SELECT_READ);

        // find a place to save connection index
        int i = 0;

        for (i = 0; i < MAX_CONNECTION_NUM; i++) {
            if (_client_fd[i] == -1) {
                break;
            }
        }

        _client_fd[i] = _c;
        _connection_index[_c] = i;

        // open a new connection to remote ip
        int _s = socket(AF_INET, SOCK_STREAM, _protocol);

        if (_s < 0) {
            if (_verbose) {
                click_chatter("%s: failed to create socket: errno: %d", declaration().c_str(),
                              _s);
            }
            return;
        }

        if (connect(_s, (struct sockaddr *) &_remote, _remote_len) < 0) {

            if (_verbose) {
                click_chatter("%s: failed to connect to %s:%d", declaration().c_str(),
                        IPAddress(_remote.sin_addr).unparse().c_str(), ntohs(_remote.sin_port));
                return ;
            }
        }

        if (_verbose)
            click_chatter("%s: opened connection %d to %s:%d", declaration().c_str(),
                          _s, IPAddress(_remote.sin_addr).unparse().c_str(), ntohs(_remote.sin_port));

        fcntl(_s, F_SETFL, O_NONBLOCK);
        fcntl(_s, F_SETFD, FD_CLOEXEC);

        add_select(_s, SELECT_READ);

        _server_fd[i] = _s;
        _connection_index[_s] = i;
    } else {

        WritablePacket *_rq = Packet::make(_headroom, 0, _snaplen, 0);

        len = recv(fd, _rq->data(), _rq->length(), 0);

        // this segment OK
        if (len > 0) {
            if (len > _snaplen) {
                // truncate packet to max length (should never happen)
                assert(_rq->length() == (uint32_t) _snaplen);
                SET_EXTRA_LENGTH_ANNO(_rq, len - _snaplen);
            } else {
                // trim packet to actual length
                _rq->take(_snaplen - len);
            }

            // set timestamp
            if (_timestamp)
                _rq->timestamp_anno().assign_now();

            // add fd
            WritablePacket *packet = _rq->push(sizeof(int));
            if (!packet) {
                if (_verbose) {
                    click_chatter("%s failed to push packet", declaration().c_str());
                }
                return;
            }

            int index = _connection_index[fd];

            if (index < 0) {
                if (_verbose) {
                    click_chatter("%s: invalid fd:%d", declaration().c_str(), fd);
                }
            }

            if (fd == _client_fd[index]) {
                memcpy(packet->data(), &_server_fd[index], sizeof(int));
            } else if (fd == _server_fd[index]) {
                memcpy(packet->data(), &_client_fd[index], sizeof(int));
            } else {
                if (_verbose) {
                    click_chatter("%s: invalid fd %d with index:%d", declaration().c_str(), fd, index);
                }
                return;
            }

            // push packet
            output(0).push(packet);
        } else if (len == 0 || errno != EAGAIN) {
            // connection terminated or fatal error
            if (len == 0 && _verbose) {
                click_chatter("%s: fd %d closed connection", declaration().c_str(), fd);
            } else if (errno != EAGAIN && _verbose) {
                click_chatter("%s:fd %d error %s", declaration().c_str(), fd, strerror(errno));
            }
            close_fd(fd);
            return;
        }
    }

}

int
MultiSocket::write_packet(int fd, Packet *p)
{
    int len;

    assert(fd >= 0);

    while (p->length()) {

        len = send(fd, p->data(), p->length(), 0);

        // error
        if (len < 0) {
            // out of memory or would block
            if (errno == ENOBUFS || errno == EAGAIN)
                return -1;

            // interrupted by signal, try again immediately
            else if (errno == EINTR)
                continue;

            // connection probably terminated or other fatal error
            else {
                if (_verbose) {
                    click_chatter("%s: packet to fd %d error: %s", declaration().c_str(), fd, strerror(errno));
                }
                close_fd(fd);
                break;
            }
        } else
            // this segment OK
            p->pull(len);
    }

    p->kill();
    return 0;
}

void
MultiSocket::push(int, Packet *p)
{
    fd_set fds;
    int err;
    int fd;

    memcpy(&fd, p->data(), sizeof(int));
    p->pull(sizeof(int));

    if (fd >= 0) {
        // block
        do {
            FD_ZERO(&fds);
            FD_SET(fd, &fds);
            err = select(fd + 1, NULL, &fds, NULL, NULL);
        } while (err < 0 && errno == EINTR);

        if (err >= 0) {
            // write
            do {
                err = write_packet(fd, p);
            } while (err < 0 && (errno == ENOBUFS || errno == EAGAIN));
        }

        if (err < 0) {
            if (_verbose)
                click_chatter("%s: %s, dropping packet", declaration().c_str(), strerror(err));
            p->kill();
        }
    } else
        p->kill();
}

CLICK_ENDDECLS
EXPORT_ELEMENT(MultiSocket)
